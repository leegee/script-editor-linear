import { createStore, unwrap } from "solid-js/store";
import { storage } from "../db";

export interface NoteType {
    id: string; // generated by CanonicalNote internally
    title: string;
    details: {
        text: string;
        urls?: string[];
        [key: string]: any; // allow extra metadata if needed
    };
}

export const [notes, setNotes] = createStore<Record<string, NoteType>>({});

// Load all notes from storage
export async function loadAllNotes() {
    const items = await storage.getAll<NoteType>("notes");
    const revived = Object.fromEntries(
        Object.entries(items).map(([id, obj]) => [id, obj as NoteType])
    );
    setNotes(revived);
}

// Reset all notes
export async function resetNotes() {
    await storage.clearTable("notes");
    setNotes({});
}

export function createNote(obj: Partial<NoteType>): NoteType {
    if ("ref" in obj) {
        throw new TypeError("createNote fields should not contain ref");
    }

    const note: NoteType = {
        id: obj.id ?? crypto.randomUUID(),
        title: obj.title ?? "New note",
        details: {
            text: obj.details?.text ?? "",
            urls: obj.details?.urls ?? [],
        },
    };

    setNotes(note.id, note);
    storage.put("notes", note);

    return note;
}

export function patchNote(id: string, updatedFields: Partial<NoteType>) {
    const prev = unwrap(notes[id]) as NoteType | undefined;
    if (!prev) throw new Error("Cannot patch non-existent note: " + id);

    const merged: NoteType = {
        ...prev,
        ...updatedFields,
        details: {
            ...prev.details,
            ...(updatedFields.details ?? {}),
        },
    };

    setNotes(id, merged);
    storage.put("notes", unwrap(merged));
}


export async function removeNote(id: string) {
    setNotes(prev => {
        const copy = { ...prev };
        delete copy[id];
        return copy;
    });
    await storage.delete("notes", id);
}

export function getNote(id: string): NoteType | undefined {
    return notes[id];
}

export function resolveNoteRef(item: { details?: { ref?: string }; id?: string }): NoteType | undefined {
    const ref = item.details?.ref ?? item.id;
    return ref ? notes[ref] : undefined;
}
